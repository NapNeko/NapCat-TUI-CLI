#!/bin/bash

MAGENTA='\033[0;1;35;95m'
RED='\033[0;1;31;91m'
YELLOW='\033[0;1;33;93m'
GREEN='\033[0;1;32;92m'
CYAN='\033[0;1;36;96m'
BLUE='\033[0;1;34;94m'
NC='\033[0m'

#  Rootless Path Configuration 
# Script runs as the current user, so $USER and $HOME are correct.
TARGET_USER="$USER"
TARGET_USER_HOME="$HOME"

INSTALL_BASE_DIR="$TARGET_USER_HOME/Napcat"
RUN_DIR="$INSTALL_BASE_DIR/run"
LOG_DIR="$INSTALL_BASE_DIR/log"
QQ_EXECUTABLE="$INSTALL_BASE_DIR/opt/QQ/qq"
PID_FILE="$RUN_DIR/napcat.pid"


# 辅助函数：递归获取所有后代 PID
_get_all_descendant_pids_old() {
    local ppid="$1"
    local children
    children=$(pgrep -P "$ppid" 2>/dev/null)
    for child in $children; do
        echo "$child"
        _get_all_descendant_pids_old "$child"
    done
}

# 辅助函数：从 PID 文件中的 PID 获取正在运行的 QQ 号
_get_running_qq_from_global_pid() {
    local pid
    local running_qq=""

    if [[ ! -f "$PID_FILE" ]] || [[ ! -r "$PID_FILE" ]]; then
        echo ""
        return
    fi

    pid=$(cat "$PID_FILE")
    #  No sudo needed to check user's own process 
    if [[ -z "$pid" ]] || ! kill -0 "$pid" &>/dev/null; then
        echo ""
        return
    fi

    # 将主 PID 和所有后代 PID 放入一个数组
    local pids_to_check=("$pid" $(_get_all_descendant_pids_old "$pid"))

    # 遍历整个进程树进行检查
    for current_pid in "${pids_to_check[@]}"; do
        local cmdline
        cmdline=$(ps -o cmd= -p "$current_pid" 2>/dev/null)
        if [[ "$cmdline" =~ --no-sandbox[[:space:]]+-q[[:space:]]+([0-9]{4,}) ]]; then
            running_qq="${BASH_REMATCH[1]}"
            echo "$running_qq"
            return
        fi
    done

    echo "" # 如果未找到，返回空
}

QQ=$2
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
CMD="xvfb-run -a '$QQ_EXECUTABLE' --no-sandbox -q $QQ"
#  Use new LOG_DIR path 
LOG_FILE="$LOG_DIR/napcat_$QQ.log"

start() {
    if [ -z "$QQ" ]; then
        echo -e "${RED}请传入QQ号,如${NC}${GREEN} $0 start 3116556127${NC}"
        exit 1
    fi

    local running_qq_now
    running_qq_now=$(_get_running_qq_from_global_pid)
    local current_pid_in_file=""
    [[ -f "$PID_FILE" ]] && current_pid_in_file=$(cat "$PID_FILE")

    if [[ -n "$running_qq_now" ]]; then
        if [[ "$running_qq_now" == "$QQ" ]]; then
            echo -e "${RED}服务已为QQ $QQ 运行 (PID: $current_pid_in_file)${NC}"
        else
            echo -e "${RED}NapCat 服务已为另一个QQ ${YELLOW}$running_qq_now${RED} 运行 (PID: $current_pid_in_file)${NC}"
            echo -e "${YELLOW}请先停止当前运行的服务。禁止多开。${NC}"
        fi
        exit 1
    else
        if [[ -f "$PID_FILE" ]]; then
            echo -e "${YELLOW}发现无效的 PID 文件，正在清理...${NC}"
            rm -f "$PID_FILE"
        fi
    fi

    #  Ensure user-owned directories exist 
    mkdir -p "$RUN_DIR" "$LOG_DIR"

    echo -e "${MAGENTA}启动 napcat 服务中 QQ: $QQ...${NC}"
    
    #  Start process as current user, no sudo needed 
    bash -c "$CMD" >> "$LOG_FILE" 2>&1 &
    local process_pid=$!

    if [[ "$process_pid" -gt 0 ]]; then
        #  Write to user-owned PID file, no sudo needed 
        echo "$process_pid" > "$PID_FILE"
        echo -e "${GREEN}服务已启动 (PID: $process_pid, QQ: $QQ, PID File: $PID_FILE)${NC}"
    else
        echo -e "${RED}启动服务失败，未能获取 PID。${NC}"
        exit 1
    fi
}

stop() {
    local running_qq_now
    running_qq_now=$(_get_running_qq_from_global_pid)
    local current_pid_in_file=""
    [[ -f "$PID_FILE" ]] && current_pid_in_file=$(cat "$PID_FILE")

    if [ -z "$QQ" ]; then # 如果没有指定 QQ，则停止 PID 文件中记录的进程
        if [[ -n "$running_qq_now" ]] && [[ -n "$current_pid_in_file" ]]; then
            echo -e "${MAGENTA}停止 napcat 服务 (PID: $current_pid_in_file, QQ: $running_qq_now)...${NC}"
            local log_to_remove="$LOG_DIR/napcat_${running_qq_now}.log"
            
            #  No sudo needed to kill/check user's own process 
            if kill "$current_pid_in_file" 2>/dev/null; then
                sleep 2
            fi
            if kill -0 "$current_pid_in_file" 2>/dev/null; then
                 echo -e "${YELLOW}正常终止失败，尝试强制终止 (PID: $current_pid_in_file)...${NC}"
                 kill -9 "$current_pid_in_file" 2>/dev/null
                 sleep 1
            fi

            if ! kill -0 "$current_pid_in_file" 2>/dev/null; then
                rm -f "$PID_FILE"
                rm -f "$log_to_remove"
                echo -e "${RED}服务已停止 (QQ: $running_qq_now)${NC}"
            else
                echo -e "${RED}无法停止服务 (PID: $current_pid_in_file)。请手动检查。${NC}"
            fi
        else
            echo -e "${GREEN}没有 Napcat 服务正在运行 (根据 $PID_FILE)${NC}"
            [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
        fi
        return 0
    fi

    # 如果指定了 QQ 号
    if [[ -n "$running_qq_now" ]] && [[ -n "$current_pid_in_file" ]]; then
        if [[ "$running_qq_now" == "$QQ" ]]; then
            echo -e "${MAGENTA}停止 napcat 服务中 QQ: $QQ (PID: $current_pid_in_file)...${NC}"
            #  No sudo needed 
            if kill "$current_pid_in_file" 2>/dev/null; then
                sleep 2
            fi
            if kill -0 "$current_pid_in_file" 2>/dev/null; then
                 echo -e "${YELLOW}正常终止失败，尝试强制终止 (PID: $current_pid_in_file)...${NC}"
                 kill -9 "$current_pid_in_file" 2>/dev/null
                 sleep 1
            fi

            if ! kill -0 "$current_pid_in_file" 2>/dev/null; then
                rm -f "$PID_FILE"
                rm -f "$LOG_FILE"
                echo -e "${RED}服务已停止 (QQ: $QQ)${NC}"
            else
                echo -e "${RED}无法停止服务 (PID: $current_pid_in_file, QQ: $QQ)。请手动检查。${NC}"
            fi
        else
            echo -e "${YELLOW}正在运行的服务是为 QQ ${running_qq_now} (PID $current_pid_in_file), 而不是请求的 QQ $QQ.${NC}"
            echo -e "${GREEN}服务 (QQ: $running_qq_now) 未停止.${NC}"
        fi
    else
        echo -e "${GREEN}服务未运行 (或 PID 文件 $PID_FILE 无效/不存在) 来停止 QQ $QQ.${NC}"
        [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
    fi
}

restart() {
    if [ -z "$QQ" ]; then
        echo -e "${RED}请传入QQ号,如${NC}${GREEN} $0 restart 3116556127${NC}"
        exit 1
    fi

    echo -e "${MAGENTA}重启 napcat 服务中 QQ: $QQ...${NC}"
    local original_qq_for_stop=$QQ
    QQ=$original_qq_for_stop stop
    QQ=$original_qq_for_stop
    sleep 2
    start
}

status() {
    local running_qq_now
    running_qq_now=$(_get_running_qq_from_global_pid)
    local current_pid_in_file=""
    [[ -f "$PID_FILE" ]] && current_pid_in_file=$(cat "$PID_FILE")

    if [ -z "$QQ" ]; then
        if [[ -n "$running_qq_now" ]] && [[ -n "$current_pid_in_file" ]]; then
            echo -e "${GREEN}Napcat 服务运行中: QQ $running_qq_now (PID: $current_pid_in_file, PID File: $PID_FILE)${NC}"
        else
            echo -e "${RED}没有 Napcat 服务正在运行 (根据 $PID_FILE)${NC}"
            [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
        fi
    else
        if [[ -n "$running_qq_now" ]] && [[ -n "$current_pid_in_file" ]]; then
            if [[ "$running_qq_now" == "$QQ" ]]; then
                echo -e "${GREEN}服务运行中 QQ: $QQ (PID: $current_pid_in_file, PID File: $PID_FILE)${NC}"
            else
                echo -e "${RED}服务未针对 QQ $QQ 运行. 当前运行的是 QQ $running_qq_now (PID: $current_pid_in_file, PID File: $PID_FILE)${NC}"
            fi
        else
            echo -e "${RED}服务未运行 QQ: $QQ (根据 $PID_FILE)${NC}"
            [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
        fi
    fi
}

log() {
    if [ -z "$QQ" ]; then
        echo -e "${RED}请传入QQ号,如${NC}${GREEN} $0 log 3116556127${NC}"
        exit 1
    fi
    if [ -f "$LOG_FILE" ]; then
        tail -n 50 "$LOG_FILE"
        echo -e "${YELLOW}正在实时监控日志 (按 Ctrl+C 退出)...${NC}"
        tail -f "$LOG_FILE"
    else
        echo -e "${RED}日志文件不存在: $LOG_FILE${NC}"
    fi
}

startup() {
    if [ -z "$QQ" ]; then
        echo -e "${RED}请传入QQ号,如${NC}${GREEN} $0 startup 3116556127${NC}"
        exit 1
    fi

    echo -e "${YELLOW}配置开机自启动需要 root 权限...${NC}"
    if ! sudo -v; then
        echo -e "${RED}无法获取 sudo 权限，操作已取消。${NC}"
        exit 1
    fi

    local init_script_path="/etc/init.d/nc_${QQ}"
    
    if sudo test -f "$init_script_path"; then
        echo -e "${GREEN}已存在QQ ${QQ} 的开机自启动服务: $init_script_path${NC}"
        read -p "是否要重新配置？ (y/N): " choice
        [[ ! "$choice" =~ ^[Yy]$ ]] && echo -e "${GREEN}操作取消。${NC}" && exit 0
    fi

    #  2. 检查是否存在其他账号的自启动脚本 
    local existing_script_file=""
    local other_qq=""
    
    for file in /etc/init.d/nc_*; do
        # 跳过不存在的文件（当没有匹配时）
        [[ ! -f "$file" ]] && continue
        
        local filename=$(basename "$file")
        # 提取 QQ 号
        if [[ "$filename" =~ nc_([0-9]+) ]] && [[ "${BASH_REMATCH[1]}" != "$QQ" ]]; then
            existing_script_file="$file"
            other_qq="${BASH_REMATCH[1]}"
            break # 只处理找到的第一个冲突
        fi
    done

    if [[ -n "$existing_script_file" ]]; then
        local existing_script_name=$(basename "$existing_script_file")
        echo -e "${YELLOW}冲突发生：${NC}"
        echo -e "已存在账号 ${CYAN}$other_qq${NC} 的开机自启动脚本 (${existing_script_name})。"
        echo ""
        echo -e "请选择操作:"
        echo -e "  ${GREEN}1${NC}) 替换 (禁用 $other_qq, 启用 $QQ)"
        echo -e "  ${RED}2${NC}) 取消添加 $QQ"
        echo ""
        read -p "请选择 (1 或 2): " conflict_choice
        
        case "$conflict_choice" in
            1)
                echo -e "${YELLOW}正在禁用并移除旧脚本 $existing_script_name ...${NC}"
                if command -v update-rc.d &> /dev/null; then
                    sudo update-rc.d "nc_${other_qq}" remove &>/dev/null
                elif command -v systemctl &> /dev/null && sudo systemctl list-unit-files | grep -q "nc_${other_qq}.service"; then
                    sudo systemctl disable "nc_${other_qq}.service" &>/dev/null
                fi
                
                if sudo rm -f "$existing_script_file"; then
                    echo -e "${GREEN}旧脚本已移除，继续添加新脚本...${NC}"
                else
                    echo -e "${RED}错误：禁用或移除旧脚本 '$existing_script_name' 失败。${NC}"
                    echo -e "${RED}请检查权限或手动操作后重试。${NC}"
                    exit 1
                fi
                ;;
            2)
                echo -e "${GREEN}添加账号 $QQ 的自启动已取消。${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}无效的选择。操作已取消。${NC}"
                exit 1
                ;;
        esac
    fi

    echo -e "${MAGENTA}正在为账号 $QQ 创建开机自启动脚本...${NC}"

    #  Generated script uses rootless paths and sudo -u 
    sudo tee "$init_script_path" > /dev/null <<EOF
#!/bin/bash
### BEGIN INIT INFO
# Provides:          nc_${QQ}
# Required-Start:    \$network \$remote_fs \$syslog
# Required-Stop:     \$network \$remote_fs \$syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Manage nc_${QQ} service
# Description:       Start of nc_${QQ} service as user ${TARGET_USER}.
### END INIT INFO

PATH=/usr/local/sbin:/usr/local/bin:/sbin:bin:/usr/sbin:/usr/bin
CMD="xvfb-run -a '${QQ_EXECUTABLE}' --no-sandbox -q ${QQ}"
PID_FILE="${PID_FILE}"
LOG_FILE="${LOG_FILE}"
RUN_AS_USER="${TARGET_USER}"

start() {
    echo "Starting NapCat for QQ ${QQ} as user \$RUN_AS_USER..."
    mkdir -p "\$(dirname "\$LOG_FILE")" "\$(dirname "\$PID_FILE")"
    chown "\$RUN_AS_USER" "\$(dirname "\$LOG_FILE")" "\$(dirname "\$PID_FILE")"
    touch "\$LOG_FILE"
    chown "\$RUN_AS_USER" "\$LOG_FILE"
    
    sudo -u "\$RUN_AS_USER" -H bash -c "nohup \$CMD >> \"\$LOG_FILE\" 2>&1 & echo \$! > \"\$PID_FILE\""
    echo "NapCat service started."
}

stop() {
    echo "Stopping NapCat service..."
    if [ -f "\$PID_FILE" ]; then
        kill \$(cat "\$PID_FILE")
        rm -f "\$PID_FILE"
    fi
    echo "NapCat service stopped."
}

case "\$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    *)
        exit 1
        ;;
esac

exit 0
EOF

    sudo chmod +x "$init_script_path"
    if command -v update-rc.d &> /dev/null; then
        sudo update-rc.d "nc_${QQ}" defaults
        echo -e "${MAGENTA}已添加QQ ${QQ} 的开机自启动服务 (SysVinit).${NC}"
    else
        echo -e "${YELLOW}未知的 init 系统，无法自动配置开机启动。脚本已创建于 ${init_script_path}${NC}"
    fi
}

startdown() {
    if [ -z "$QQ" ]; then
        echo -e "${RED}请传入QQ号,如${NC}${GREEN} $0 startdown 3116556127${NC}"
        exit 1
    fi

    echo -e "${YELLOW}取消开机自启动需要 root 权限...${NC}"
    if ! sudo -v; then
        echo -e "${RED}无法获取 sudo 权限，操作已取消。${NC}"
        exit 1
    fi

    local init_script_path="/etc/init.d/nc_${QQ}"
    if ! sudo test -f "$init_script_path"; then
        echo -e "${RED}不存在QQ ${QQ} 的开机自启动服务: $init_script_path${NC}"
        exit 1
    fi

    if command -v update-rc.d &> /dev/null; then
        sudo update-rc.d "nc_${QQ}" remove
    fi
    sudo rm -f "$init_script_path"
    echo -e "${MAGENTA}已取消QQ ${QQ} 的开机自启动服务.${NC}"
}

update() {
    local current_qq_for_stop=""
    QQ=$current_qq_for_stop stop
    echo -e "${YELLOW}正在执行更新脚本 (需要 sudo)...${NC}"
    curl -sSL https://nclatest.znin.net/NapNeko/NapCat-Installer/main/script/install.sh | sudo bash -s -- --docker n --cli y
    echo -e "${GREEN}更新完成。如果之前有服务运行，请重新启动。${NC}"
}

rebuild() {
    local current_qq_for_stop=""
    QQ=$current_qq_for_stop stop
    echo -e "${YELLOW}正在执行强制重建脚本 (需要 sudo)...${NC}"
    curl -sSL https://nclatest.znin.net/NapNeko/NapCat-Installer/main/script/install.sh | sudo bash -s -- --docker n --cli y --force
    echo -e "${GREEN}强制重建完成。如果之前有服务运行，请重新启动。${NC}"
}

#  REWRITTEN: remove function for rootless 
remove() {
    local current_qq_for_stop=""
    QQ=$current_qq_for_stop stop # 停止任何正在运行的实例

    echo -e "${YELLOW}正在尝试移除所有 nc_QQ 开机自启动项 (需要 sudo)...${NC}"
    if sudo -v; then
        for old_init_script in /etc/init.d/nc_*; do
            if sudo test -f "$old_init_script"; then
                local old_qq_num=$(basename "$old_init_script" | sed 's/nc_//')
                echo "Removing startup for QQ $old_qq_num..."
                if command -v update-rc.d &> /dev/null; then
                    sudo update-rc.d "nc_${old_qq_num}" remove &>/dev/null
                fi
                sudo rm -f "$old_init_script"
            fi
        done
    else
        echo -e "${RED}无法获取 sudo 权限，跳过移除开机自启动项。${NC}"
    fi

    echo -e "${YELLOW}正在删除用户 ${TARGET_USER} 的 Napcat 相关目录和文件...${NC}"
    rm -rf "$INSTALL_BASE_DIR"
    rm -rf "$TARGET_USER_HOME/.config/QQ"

    echo -e "${YELLOW}正在清理 CLI 脚本 (需要 sudo)...${NC}"
    sudo rm -f /usr/local/bin/napcat /usr/local/bin/_napcat*

    echo -e "${GREEN}卸载完成。${NC}"
    echo -e "${MAGENTA}江${RED}湖${GREEN}不${CYAN}散，${MAGENTA}有${RED}缘${GREEN}再${CYAN}见。${NC}"
}

help() {
    clear
    echo -e " ${MAGENTA}┌${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}${RED}─┐${NC}"
    echo -e " ${MAGENTA}│${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA} ${RED}│${NC}"
    echo -e " ${RED}│${YELLOW}██${GREEN}█╗${CYAN}  ${BLUE} █${MAGENTA}█╗${RED}  ${YELLOW}  ${GREEN} █${CYAN}██${BLUE}██${MAGENTA}╗ ${RED}  ${YELLOW}  ${GREEN}██${CYAN}██${BLUE}██${MAGENTA}╗ ${RED}  ${YELLOW}  ${GREEN} █${CYAN}██${BLUE}██${MAGENTA}█╗${RED}  ${YELLOW}  ${GREEN} █${CYAN}██${BLUE}██${MAGENTA}╗ ${RED}  ${YELLOW}  ${GREEN}██${CYAN}██${BLUE}██${MAGENTA}██${RED}╗${YELLOW}│${NC}"
    echo -e " ${YELLOW}│${GREEN}██${CYAN}██${BLUE}╗ ${MAGENTA} █${RED}█║${YELLOW}  ${GREEN}  ${CYAN}██${BLUE}╔═${MAGENTA}═█${RED}█╗${YELLOW}  ${GREEN}  ${CYAN}██${BLUE}╔═${MAGENTA}═█${RED}█╗${YELLOW}  ${GREEN}  ${CYAN}██${BLUE}╔═${MAGENTA}══${RED}═╝${YELLOW}  ${GREEN}  ${CYAN}██${BLUE}╔═${MAGENTA}═█${RED}█╗${YELLOW}  ${GREEN}  ${CYAN}╚═${BLUE}═█${MAGENTA}█╔${RED}══${YELLOW}╝${YELLOW}│${NC}"
    echo -e " ${GREEN}│${CYAN}██${BLUE}╔█${MAGENTA}█╗${RED} █${YELLOW}█║${GREEN}  ${CYAN}  ${BLUE}██${MAGENTA}██${RED}██${YELLOW}█║${GREEN}  ${CYAN}  ${BLUE}██${MAGENTA}██${RED}██${YELLOW}╔╝${GREEN}  ${CYAN}  ${BLUE}██${MAGENTA}║ ${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}██${MAGENTA}██${RED}██${YELLOW}█║${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA} █${RED}█║${YELLOW}  ${GREEN} ${GREEN}│${NC}"
    echo -e " ${CYAN}│${BLUE}██${MAGENTA}║╚${RED}██${YELLOW}╗█${GREEN}█║${CYAN}  ${BLUE}  ${MAGENTA}██${RED}╔═${YELLOW}═█${GREEN}█║${CYAN}  ${BLUE}  ${MAGENTA}██${RED}╔═${YELLOW}══${GREEN}╝ ${CYAN}  ${BLUE}  ${MAGENTA}██${RED}║ ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}██${RED}╔═${YELLOW}═█${GREEN}█║${CYAN}  ${BLUE}  ${MAGENTA}  ${RED} █${YELLOW}█║${GREEN}  ${CYAN} ${CYAN}│${NC}"
    echo -e " ${BLUE}│${MAGENTA}██${RED}║ ${YELLOW}╚█${GREEN}██${CYAN}█║${BLUE}  ${MAGENTA}  ${RED}██${YELLOW}║ ${GREEN} █${CYAN}█║${BLUE}  ${MAGENTA}  ${RED}██${YELLOW}║ ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}╚█${YELLOW}██${GREEN}██${CYAN}█╗${BLUE}  ${MAGENTA}  ${RED}██${YELLOW}║ ${GREEN} █${CYAN}█║${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW} █${GREEN}█║${CYAN}  ${BLUE} ${BLUE}│${NC}"
    echo -e " ${MAGENTA}│${RED}╚═${YELLOW}╝ ${GREEN} ╚${CYAN}══${BLUE}═╝${MAGENTA}  ${RED}  ${YELLOW}╚═${GREEN}╝ ${CYAN} ╚${BLUE}═╝${MAGENTA}  ${RED}  ${YELLOW}╚═${GREEN}╝ ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW} ╚${GREEN}══${CYAN}══${BLUE}═╝${MAGENTA}  ${RED}  ${YELLOW}╚═${GREEN}╝ ${CYAN} ╚${BLUE}═╝${MAGENTA}  ${RED}  ${YELLOW}  ${GREEN} ╚${CYAN}═╝${BLUE}  ${MAGENTA} ${MAGENTA}│${NC}"
    echo -e " ${RED}└${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}${YELLOW}─┘${NC}"
    echo
    echo -e "${MAGENTA}napcat 控制脚本${NC}"
    echo
    echo -e "${MAGENTA}使用方法: ${NC}"
    echo -e "${CYAN}  napcat {start|restart|status|log|startup|startdown} QQ号${NC}"
    echo -e "${CYAN}  napcat {stop} [QQ号可选] ${NC} # 不带QQ号则停止当前运行的任何实例"
    echo -e "${CYAN}  napcat {update|rebuild|remove|help|oldhelp}${NC}"
    echo
    echo -e " ${GREEN}   napcat start {QQ}                     ${MAGENTA}启动对应QQ号的NAPCAT ${NC}"
    echo -e " ${GREEN}   napcat stop {QQ}[可选]                ${MAGENTA}停止当前的NAPCAT实例${NC}"
    echo -e " ${GREEN}   napcat restart {QQ}                   ${MAGENTA}重启对应QQ号的NAPCAT ${NC}"
    echo -e " ${GREEN}   napcat status {QQ}[可选]              ${MAGENTA}查看当前的NAPCAT状态${NC}"
    echo -e " ${GREEN}   napcat log {QQ}                       ${MAGENTA}查看对应QQ号的NAPCAT日志${NC}"
    echo -e " ${GREEN}   napcat startup {QQ}                   ${MAGENTA}添加开机自启动对应QQ号的NAPCAT ${NC}"
    echo -e " ${GREEN}   napcat startdown {QQ}                 ${MAGENTA}取消开机自启动对应QQ号的NAPCAT${NC}"
    echo -e " ${GREEN}   napcat update                         ${MAGENTA}更新 NAPCAT及QQ (会先停止当前实例)${NC}"
    echo -e " ${GREEN}   napcat rebuild                        ${MAGENTA}重建 NAPCAT及QQ (会先停止当前实例)${NC}"
    echo -e " ${GREEN}   napcat remove                         ${MAGENTA}卸载 NAPCAT及QQ (会先停止并移除自启)${NC}"
    echo -e " ${GREEN}   napcat help                           ${MAGENTA}查看此帮助${NC}"
    echo -e " ${GREEN}   napcat oldhelp                        ${MAGENTA}查看旧版手动命令提示${NC}"
}

#  oldhelp for rootless 
oldhelp() {
    echo -e "手动命令提示:"
    echo -e "直接启动 (前台): ${GREEN} xvfb-run -a ~/Napcat/opt/QQ/qq --no-sandbox -q QQ号码 ${NC}"
    echo -e "使用 screen 后台运行: ${GREEN} screen -dmS napcat xvfb-run -a ~/Napcat/opt/QQ/qq --no-sandbox -q QQ号码 ${NC}"
    echo -e "连接到 screen 会话: ${GREEN} screen -r napcat ${NC} (使用 Ctrl+A 然后 D 分离)"
    echo -e "停止 screen 会话: ${GREEN} screen -S napcat -X quit ${NC}"
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart)
        restart
        ;;
    status)
        status
        ;;
    log)
        log
        ;;
    startup)
        startup
        ;;
    startdown)
        startdown
        ;;
    update)
        update
        ;;
    rebuild)
        rebuild
        ;;
    remove)
        remove
        ;;
    help)
        help
        exit 0
        ;;
    oldhelp)
        oldhelp
        exit 0
        ;;
    *)
        help
        exit 1
        ;;
esac

exit 0