#!/bin/bash

MAGENTA='\033[0;1;35;95m'
RED='\033[0;1;31;91m'
YELLOW='\033[0;1;33;93m'
GREEN='\033[0;1;32;92m'
CYAN='\033[0;1;36;96m'
BLUE='\033[0;1;34;94m'
NC='\033[0m'

#  Rootless Path Configuration 
# Script runs as the current user, so $USER and $HOME are correct.
TARGET_USER="$USER"
TARGET_USER_HOME="$HOME"

INSTALL_BASE_DIR="$TARGET_USER_HOME/Napcat"
RUN_DIR="$INSTALL_BASE_DIR/run"
LOG_DIR="$INSTALL_BASE_DIR/log"
QQ_EXECUTABLE="$INSTALL_BASE_DIR/opt/QQ/qq"
PID_FILE="$RUN_DIR/napcat.pid"


# 辅助函数：递归获取所有后代 PID
_get_all_descendant_pids_old() {
    local ppid="$1"
    local children
    children=$(pgrep -P "$ppid" 2>/dev/null)
    for child in $children; do
        echo "$child"
        _get_all_descendant_pids_old "$child"
    done
}

# 新的核心辅助函数：查找所有顶层Napcat进程
# 返回一个由PID和QQ号组成的字符串数组，格式为 "PID:QQ"
_find_top_level_instances() {
    local candidate_pids
    local top_level_pids=()
    local instance_info=()

    readarray -t candidate_pids < <(pgrep -u "$TARGET_USER" -f ".*/qq --no-sandbox -q [0-9]{4,}")
    if [[ ${#candidate_pids[@]} -eq 0 ]]; then
        echo "" # 返回空
        return
    fi

    for pid in "${candidate_pids[@]}"; do
        local ppid=$(ps -o ppid= -p "$pid" | tr -d ' ')
        local is_child=false
        for other_pid in "${candidate_pids[@]}"; do
            if [[ "$ppid" == "$other_pid" ]]; then
                is_child=true
                break
            fi
        done
        if ! $is_child; then
            top_level_pids+=("$pid")
        fi
    done

    for pid in "${top_level_pids[@]}"; do
        local cmdline=$(ps -o cmd= -p "$pid" 2>/dev/null)
        if [[ "$cmdline" =~ --no-sandbox[[:space:]]+-q[[:space:]]+([0-9]{4,}) ]]; then
            instance_info+=("${pid}:${BASH_REMATCH[1]}")
        fi
    done
    
    echo "${instance_info[@]}" # 返回空格分隔的 "PID:QQ" 列表
}


QQ=$2
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
CMD="xvfb-run -a '$QQ_EXECUTABLE' --no-sandbox -q $QQ"
LOG_FILE="$LOG_DIR/napcat_$QQ.log"

start() {
    if [ -z "$QQ" ]; then
        echo -e "${RED}请传入QQ号,如${NC}${GREEN} $0 start 3116556127${NC}"
        exit 1
    fi

    local running_instances_str=$(_find_top_level_instances)
    if [[ -n "$running_instances_str" ]]; then
        echo -e "${RED}错误：检测到正在运行的 Napcat 实例。禁止多开。${NC}"
        local instances=($running_instances_str)
        for instance in "${instances[@]}"; do
            local pid=${instance%%:*}
            local running_qq=${instance##*:}
            echo -e "${YELLOW}  - PID: $pid, QQ: $running_qq${NC}"
        done
        echo -e "${YELLOW}请先使用 'napcat stop' 停止所有实例。${NC}"
        exit 1
    fi
    
    # 清理可能残留的PID文件
    [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"

    mkdir -p "$RUN_DIR" "$LOG_DIR"

    echo -e "${MAGENTA}启动 napcat 服务中 QQ: $QQ...${NC}"
    
    bash -c "$CMD" >> "$LOG_FILE" 2>&1 &
    local process_pid=$!

    if [[ "$process_pid" -gt 0 ]]; then
        # 等待一下，让xvfb-run启动真正的qq进程
        sleep 1
        # 查找顶层进程并写入PID文件
        local final_pid=""
        local running_instances_str=$(_find_top_level_instances)
        if [[ -n "$running_instances_str" ]]; then
            local instances=($running_instances_str)
            # 假设只有一个实例被我们刚刚启动
            final_pid=${instances[0]%%:*}
        fi

        if [[ -n "$final_pid" ]]; then
            echo "$final_pid" > "$PID_FILE"
            echo -e "${GREEN}服务已启动 (PID: $final_pid, QQ: $QQ, PID File: $PID_FILE)${NC}"
        else
            # 如果找不到，回退到使用bash的PID
            echo "$process_pid" > "$PID_FILE"
            echo -e "${YELLOW}警告：未能精确定位顶层进程，使用初始PID: $process_pid。${NC}"
            echo -e "${GREEN}服务已启动 (QQ: $QQ, PID File: $PID_FILE)${NC}"
        fi
    else
        echo -e "${RED}启动服务失败，未能获取 PID。${NC}"
        exit 1
    fi
}

stop() {
    local running_instances_str=$(_find_top_level_instances)
    if [[ -z "$running_instances_str" ]]; then
        echo -e "${GREEN}没有 Napcat 服务正在运行。${NC}"
        [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
        return
    fi

    local instances=($running_instances_str)
    local pids_to_kill=()
    
    if [ -z "$QQ" ]; then # 如果没有指定 QQ，则停止所有实例
        echo -e "${MAGENTA}正在停止所有 Napcat 实例...${NC}"
        for instance in "${instances[@]}"; do
            pids_to_kill+=("${instance%%:*}")
        done
    else # 如果指定了 QQ 号
        local found=false
        for instance in "${instances[@]}"; do
            local pid=${instance%%:*}
            local running_qq=${instance##*:}
            if [[ "$running_qq" == "$QQ" ]]; then
                echo -e "${MAGENTA}正在停止 napcat 服务中 QQ: $QQ (PID: $pid)...${NC}"
                pids_to_kill+=("$pid")
                found=true
            fi
        done
        if ! $found; then
            echo -e "${YELLOW}没有找到为 QQ $QQ 运行的服务。${NC}"
            return
        fi
    fi

    if [[ ${#pids_to_kill[@]} -eq 0 ]]; then
        echo -e "${GREEN}无需操作。${NC}"
        return
    fi

    for pid in "${pids_to_kill[@]}"; do
        local all_pids=("$pid" $(_get_all_descendant_pids_old "$pid"))
        kill "${all_pids[@]}" 2>/dev/null
    done
    sleep 2

    local all_stopped=true
    for pid in "${pids_to_kill[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "${YELLOW}正常终止失败，尝试强制终止 (PID: $pid)...${NC}"
            local all_pids=("$pid" $(_get_all_descendant_pids_old "$pid"))
            kill -9 "${all_pids[@]}" 2>/dev/null
            sleep 1
        fi
        if kill -0 "$pid" 2>/dev/null; then
            all_stopped=false
            echo -e "${RED}无法停止服务 (PID: $pid)。请手动检查。${NC}"
        fi
    done

    if $all_stopped; then
        rm -f "$PID_FILE"
        echo -e "${RED}服务已停止。${NC}"
    fi
}

restart() {
    if [ -z "$QQ" ]; then
        echo -e "${RED}请传入QQ号,如${NC}${GREEN} $0 restart 3116556127${NC}"
        exit 1
    fi

    echo -e "${MAGENTA}重启 napcat 服务中 QQ: $QQ...${NC}"
    local original_qq_for_stop=$QQ
    QQ=$original_qq_for_stop stop
    QQ=$original_qq_for_stop
    sleep 2
    start
}

status() {
    local running_instances_str=$(_find_top_level_instances)
    if [[ -z "$running_instances_str" ]]; then
        echo -e "${RED}没有 Napcat 服务正在运行。${NC}"
        [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
        return
    fi

    local instances=($running_instances_str)
    echo -e "${GREEN}检测到 ${#instances[@]} 个正在运行的 Napcat 实例:${NC}"
    for instance in "${instances[@]}"; do
        local pid=${instance%%:*}
        local running_qq=${instance##*:}
        
        if [ -z "$QQ" ] || [[ "$QQ" == "$running_qq" ]]; then
             echo -e "  - ${GREEN}运行中${NC}: QQ ${CYAN}$running_qq${NC} (PID: ${YELLOW}$pid${NC})"
        fi
    done
}

log() {
    if [ -z "$QQ" ]; then
        echo -e "${RED}请传入QQ号,如${NC}${GREEN} $0 log 3116556127${NC}"
        exit 1
    fi
    if [ -f "$LOG_FILE" ]; then
        tail -n 50 "$LOG_FILE"
        echo -e "${YELLOW}正在实时监控日志 (按 Ctrl+C 退出)...${NC}"
        tail -f "$LOG_FILE"
    else
        echo -e "${RED}日志文件不存在: $LOG_FILE${NC}"
    fi
}

startup() {
    if [ -z "$QQ" ]; then
        echo -e "${RED}请传入QQ号,如${NC}${GREEN} $0 startup 3116556127${NC}"
        exit 1
    fi

    echo -e "${YELLOW}配置开机自启动需要 root 权限...${NC}"
    if ! sudo -v; then
        echo -e "${RED}无法获取 sudo 权限，操作已取消。${NC}"
        exit 1
    fi

    local init_script_path="/etc/init.d/nc_${QQ}"
    
    if sudo test -f "$init_script_path"; then
        echo -e "${GREEN}已存在QQ ${QQ} 的开机自启动服务: $init_script_path${NC}"
        read -p "是否要重新配置？ (y/N): " choice
        [[ ! "$choice" =~ ^[Yy]$ ]] && echo -e "${GREEN}操作取消。${NC}" && exit 0
    fi

    #  2. 检查是否存在其他账号的自启动脚本 
    local existing_script_file=""
    local other_qq=""
    
    for file in /etc/init.d/nc_*; do
        # 跳过不存在的文件（当没有匹配时）
        [[ ! -f "$file" ]] && continue
        
        local filename=$(basename "$file")
        # 提取 QQ 号
        if [[ "$filename" =~ nc_([0-9]+) ]] && [[ "${BASH_REMATCH[1]}" != "$QQ" ]]; then
            existing_script_file="$file"
            other_qq="${BASH_REMATCH[1]}"
            break # 只处理找到的第一个冲突
        fi
    done

    if [[ -n "$existing_script_file" ]]; then
        local existing_script_name=$(basename "$existing_script_file")
        echo -e "${YELLOW}冲突发生：${NC}"
        echo -e "已存在账号 ${CYAN}$other_qq${NC} 的开机自启动脚本 (${existing_script_name})。"
        echo ""
        echo -e "请选择操作:"
        echo -e "  ${GREEN}1${NC}) 替换 (禁用 $other_qq, 启用 $QQ)"
        echo -e "  ${RED}2${NC}) 取消添加 $QQ"
        echo ""
        read -p "请选择 (1 或 2): " conflict_choice
        
        case "$conflict_choice" in
            1)
                echo -e "${YELLOW}正在禁用并移除旧脚本 $existing_script_name ...${NC}"
                if command -v update-rc.d &> /dev/null; then
                    sudo update-rc.d "nc_${other_qq}" remove &>/dev/null
                elif command -v systemctl &> /dev/null && sudo systemctl list-unit-files | grep -q "nc_${other_qq}.service"; then
                    sudo systemctl disable "nc_${other_qq}.service" &>/dev/null
                fi
                
                if sudo rm -f "$existing_script_file"; then
                    echo -e "${GREEN}旧脚本已移除，继续添加新脚本...${NC}"
                else
                    echo -e "${RED}错误：禁用或移除旧脚本 '$existing_script_name' 失败。${NC}"
                    echo -e "${RED}请检查权限或手动操作后重试。${NC}"
                    exit 1
                fi
                ;;
            2)
                echo -e "${GREEN}添加账号 $QQ 的自启动已取消。${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}无效的选择。操作已取消。${NC}"
                exit 1
                ;;
        esac
    fi

    echo -e "${MAGENTA}正在为账号 $QQ 创建开机自启动脚本...${NC}"

    #  Generated script uses rootless paths and sudo -u 
    sudo tee "$init_script_path" > /dev/null <<EOF
#!/bin/bash
### BEGIN INIT INFO
# Provides:          nc_${QQ}
# Required-Start:    \$network \$remote_fs \$syslog
# Required-Stop:     \$network \$remote_fs \$syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Manage nc_${QQ} service
# Description:       Start of nc_${QQ} service as user ${TARGET_USER}.
### END INIT INFO

PATH=/usr/local/sbin:/usr/local/bin:/sbin:bin:/usr/sbin:/usr/bin
CMD="xvfb-run -a '${QQ_EXECUTABLE}' --no-sandbox -q ${QQ}"
PID_FILE="${PID_FILE}"
LOG_FILE="${LOG_FILE}"
RUN_AS_USER="${TARGET_USER}"

start() {
    echo "Starting NapCat for QQ ${QQ} as user \$RUN_AS_USER..."
    mkdir -p "\$(dirname "\$LOG_FILE")" "\$(dirname "\$PID_FILE")"
    chown "\$RUN_AS_USER" "\$(dirname "\$LOG_FILE")" "\$(dirname "\$PID_FILE")"
    touch "\$LOG_FILE"
    chown "\$RUN_AS_USER" "\$LOG_FILE"
    
    sudo -u "\$RUN_AS_USER" -H bash -c "nohup \$CMD >> \"\$LOG_FILE\" 2>&1 & echo \$! > \"\$PID_FILE\""
    echo "NapCat service started."
}

stop() {
    echo "Stopping NapCat service..."
    if [ -f "\$PID_FILE" ]; then
        kill \$(cat "\$PID_FILE")
        rm -f "\$PID_FILE"
    fi
    echo "NapCat service stopped."
}

case "\$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    *)
        exit 1
        ;;
esac

exit 0
EOF

    sudo chmod +x "$init_script_path"
    if command -v update-rc.d &> /dev/null; then
        sudo update-rc.d "nc_${QQ}" defaults
        echo -e "${MAGENTA}已添加QQ ${QQ} 的开机自启动服务 (SysVinit).${NC}"
    else
        echo -e "${YELLOW}未知的 init 系统，无法自动配置开机启动。脚本已创建于 ${init_script_path}${NC}"
    fi
}

startdown() {
    if [ -z "$QQ" ]; then
        echo -e "${RED}请传入QQ号,如${NC}${GREEN} $0 startdown 3116556127${NC}"
        exit 1
    fi

    echo -e "${YELLOW}取消开机自启动需要 root 权限...${NC}"
    if ! sudo -v; then
        echo -e "${RED}无法获取 sudo 权限，操作已取消。${NC}"
        exit 1
    fi

    local init_script_path="/etc/init.d/nc_${QQ}"
    if ! sudo test -f "$init_script_path"; then
        echo -e "${RED}不存在QQ ${QQ} 的开机自启动服务: $init_script_path${NC}"
        exit 1
    fi

    if command -v update-rc.d &> /dev/null; then
        sudo update-rc.d "nc_${QQ}" remove
    fi
    sudo rm -f "$init_script_path"
    echo -e "${MAGENTA}已取消QQ ${QQ} 的开机自启动服务.${NC}"
}

update() {
    local current_qq_for_stop=""
    QQ=$current_qq_for_stop stop
    echo -e "${YELLOW}正在执行更新脚本 (需要 sudo)...${NC}"
    curl -sSL https://nclatest.znin.net/NapNeko/NapCat-Installer/main/script/install.sh | sudo bash -s -- --docker n --cli y
    echo -e "${GREEN}更新完成。如果之前有服务运行，请重新启动。${NC}"
}

rebuild() {
    local current_qq_for_stop=""
    QQ=$current_qq_for_stop stop
    echo -e "${YELLOW}正在执行强制重建脚本 (需要 sudo)...${NC}"
    curl -sSL https://nclatest.znin.net/NapNeko/NapCat-Installer/main/script/install.sh | sudo bash -s -- --docker n --cli y --force
    echo -e "${GREEN}强制重建完成。如果之前有服务运行，请重新启动。${NC}"
}

#  REWRITTEN: remove function for rootless 
remove() {
    local current_qq_for_stop=""
    QQ=$current_qq_for_stop stop # 停止任何正在运行的实例

    echo -e "${YELLOW}正在尝试移除所有 nc_QQ 开机自启动项 (需要 sudo)...${NC}"
    if sudo -v; then
        for old_init_script in /etc/init.d/nc_*; do
            if sudo test -f "$old_init_script"; then
                local old_qq_num=$(basename "$old_init_script" | sed 's/nc_//')
                echo "Removing startup for QQ $old_qq_num..."
                if command -v update-rc.d &> /dev/null; then
                    sudo update-rc.d "nc_${old_qq_num}" remove &>/dev/null
                fi
                sudo rm -f "$old_init_script"
            fi
        done
    else
        echo -e "${RED}无法获取 sudo 权限，跳过移除开机自启动项。${NC}"
    fi

    echo -e "${YELLOW}正在删除用户 ${TARGET_USER} 的 Napcat 相关目录和文件...${NC}"
    rm -rf "$INSTALL_BASE_DIR"
    rm -rf "$TARGET_USER_HOME/.config/QQ"

    echo -e "${YELLOW}正在清理 CLI 脚本 (需要 sudo)...${NC}"
    sudo rm -f /usr/local/bin/napcat /usr/local/bin/_napcat*

    echo -e "${GREEN}卸载完成。${NC}"
    echo -e "${MAGENTA}江${RED}湖${GREEN}不${CYAN}散，${MAGENTA}有${RED}缘${GREEN}再${CYAN}见。${NC}"
}

help() {
    clear
    echo -e " ${MAGENTA}┌${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}${RED}─┐${NC}"
    echo -e " ${MAGENTA}│${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA} ${RED}│${NC}"
    echo -e " ${RED}│${YELLOW}██${GREEN}█╗${CYAN}  ${BLUE} █${MAGENTA}█╗${RED}  ${YELLOW}  ${GREEN} █${CYAN}██${BLUE}██${MAGENTA}╗ ${RED}  ${YELLOW}  ${GREEN}██${CYAN}██${BLUE}██${MAGENTA}╗ ${RED}  ${YELLOW}  ${GREEN} █${CYAN}██${BLUE}██${MAGENTA}█╗${RED}  ${YELLOW}  ${GREEN} █${CYAN}██${BLUE}██${MAGENTA}╗ ${RED}  ${YELLOW}  ${GREEN}██${CYAN}██${BLUE}██${MAGENTA}██${RED}╗${YELLOW}│${NC}"
    echo -e " ${YELLOW}│${GREEN}██${CYAN}██${BLUE}╗ ${MAGENTA} █${RED}█║${YELLOW}  ${GREEN}  ${CYAN}██${BLUE}╔═${MAGENTA}═█${RED}█╗${YELLOW}  ${GREEN}  ${CYAN}██${BLUE}╔═${MAGENTA}═█${RED}█╗${YELLOW}  ${GREEN}  ${CYAN}██${BLUE}╔═${MAGENTA}══${RED}═╝${YELLOW}  ${GREEN}  ${CYAN}██${BLUE}╔═${MAGENTA}═█${RED}█╗${YELLOW}  ${GREEN}  ${CYAN}╚═${BLUE}═█${MAGENTA}█╔${RED}══${YELLOW}╝${YELLOW}│${NC}"
    echo -e " ${GREEN}│${CYAN}██${BLUE}╔█${MAGENTA}█╗${RED} █${YELLOW}█║${GREEN}  ${CYAN}  ${BLUE}██${MAGENTA}██${RED}██${YELLOW}█║${GREEN}  ${CYAN}  ${BLUE}██${MAGENTA}██${RED}██${YELLOW}╔╝${GREEN}  ${CYAN}  ${BLUE}██${MAGENTA}║ ${RED}  ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}██${MAGENTA}██${RED}██${YELLOW}█║${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA} █${RED}█║${YELLOW}  ${GREEN} ${GREEN}│${NC}"
    echo -e " ${CYAN}│${BLUE}██${MAGENTA}║╚${RED}██${YELLOW}╗█${GREEN}█║${CYAN}  ${BLUE}  ${MAGENTA}██${RED}╔═${YELLOW}═█${GREEN}█║${CYAN}  ${BLUE}  ${MAGENTA}██${RED}╔═${YELLOW}══${GREEN}╝ ${CYAN}  ${BLUE}  ${MAGENTA}██${RED}║ ${YELLOW}  ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}██${RED}╔═${YELLOW}═█${GREEN}█║${CYAN}  ${BLUE}  ${MAGENTA}  ${RED} █${YELLOW}█║${GREEN}  ${CYAN} ${CYAN}│${NC}"
    echo -e " ${BLUE}│${MAGENTA}██${RED}║ ${YELLOW}╚█${GREEN}██${CYAN}█║${BLUE}  ${MAGENTA}  ${RED}██${YELLOW}║ ${GREEN} █${CYAN}█║${BLUE}  ${MAGENTA}  ${RED}██${YELLOW}║ ${GREEN}  ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}╚█${YELLOW}██${GREEN}██${CYAN}█╗${BLUE}  ${MAGENTA}  ${RED}██${YELLOW}║ ${GREEN} █${CYAN}█║${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW} █${GREEN}█║${CYAN}  ${BLUE} ${BLUE}│${NC}"
    echo -e " ${MAGENTA}│${RED}╚═${YELLOW}╝ ${GREEN} ╚${CYAN}══${BLUE}═╝${MAGENTA}  ${RED}  ${YELLOW}╚═${GREEN}╝ ${CYAN} ╚${BLUE}═╝${MAGENTA}  ${RED}  ${YELLOW}╚═${GREEN}╝ ${CYAN}  ${BLUE}  ${MAGENTA}  ${RED}  ${YELLOW} ╚${GREEN}══${CYAN}══${BLUE}═╝${MAGENTA}  ${RED}  ${YELLOW}╚═${GREEN}╝ ${CYAN} ╚${BLUE}═╝${MAGENTA}  ${RED}  ${YELLOW}  ${GREEN} ╚${CYAN}═╝${BLUE}  ${MAGENTA} ${MAGENTA}│${NC}"
    echo -e " ${RED}└${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}──${YELLOW}──${GREEN}──${CYAN}──${BLUE}──${MAGENTA}──${RED}${YELLOW}─┘${NC}"
    echo
    echo -e "${MAGENTA}napcat 控制脚本${NC}"
    echo
    echo -e "${MAGENTA}使用方法: ${NC}"
    echo -e "${CYAN}  napcat {start|restart|status|log|startup|startdown} QQ号${NC}"
    echo -e "${CYAN}  napcat {stop} [QQ号可选] ${NC} # 不带QQ号则停止当前运行的任何实例"
    echo -e "${CYAN}  napcat {update|rebuild|remove|help|oldhelp}${NC}"
    echo
    echo -e " ${GREEN}   napcat start {QQ}                     ${MAGENTA}启动对应QQ号的NAPCAT ${NC}"
    echo -e " ${GREEN}   napcat stop {QQ}[可选]                ${MAGENTA}停止当前的NAPCAT实例${NC}"
    echo -e " ${GREEN}   napcat restart {QQ}                   ${MAGENTA}重启对应QQ号的NAPCAT ${NC}"
    echo -e " ${GREEN}   napcat status {QQ}[可选]              ${MAGENTA}查看当前的NAPCAT状态${NC}"
    echo -e " ${GREEN}   napcat log {QQ}                       ${MAGENTA}查看对应QQ号的NAPCAT日志${NC}"
    echo -e " ${GREEN}   napcat startup {QQ}                   ${MAGENTA}添加开机自启动对应QQ号的NAPCAT ${NC}"
    echo -e " ${GREEN}   napcat startdown {QQ}                 ${MAGENTA}取消开机自启动对应QQ号的NAPCAT${NC}"
    echo -e " ${GREEN}   napcat update                         ${MAGENTA}更新 NAPCAT及QQ (会先停止当前实例)${NC}"
    echo -e " ${GREEN}   napcat rebuild                        ${MAGENTA}重建 NAPCAT及QQ (会先停止当前实例)${NC}"
    echo -e " ${GREEN}   napcat remove                         ${MAGENTA}卸载 NAPCAT及QQ (会先停止并移除自启)${NC}"
    echo -e " ${GREEN}   napcat help                           ${MAGENTA}查看此帮助${NC}"
    echo -e " ${GREEN}   napcat oldhelp                        ${MAGENTA}查看旧版手动命令提示${NC}"
}

#  oldhelp for rootless 
oldhelp() {
    echo -e "手动命令提示:"
    echo -e "直接启动 (前台): ${GREEN} xvfb-run -a ~/Napcat/opt/QQ/qq --no-sandbox -q QQ号码 ${NC}"
    echo -e "使用 screen 后台运行: ${GREEN} screen -dmS napcat xvfb-run -a ~/Napcat/opt/QQ/qq --no-sandbox -q QQ号码 ${NC}"
    echo -e "连接到 screen 会话: ${GREEN} screen -r napcat ${NC} (使用 Ctrl+A 然后 D 分离)"
    echo -e "停止 screen 会话: ${GREEN} screen -S napcat -X quit ${NC}"
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart)
        restart
        ;;
    status)
        status
        ;;
    log)
        log
        ;;
    startup)
        startup
        ;;
    startdown)
        startdown
        ;;
    update)
        update
        ;;
    rebuild)
        rebuild
        ;;
    remove)
        remove
        ;;
    help)
        help
        exit 0
        ;;
    oldhelp)
        oldhelp
        exit 0
        ;;
    *)
        help
        exit 1
        ;;
esac

exit 0